<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Scanner: Fixed Layout</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        :root { --bg: #212529; --panel: #f8f9fa; --accent: #0d6efd; --border: #dee2e6; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            margin: 0; display: flex; flex-direction: column; height: 100vh; background: var(--bg); 
            overscroll-behavior: none;
        }
        
        /* --- TOOLBAR --- */
        .toolbar { 
            background: var(--panel); padding: 8px; display: flex; gap: 8px; align-items: center; 
            border-bottom: 1px solid var(--border); z-index: 100; flex-wrap: wrap; justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .group { display: flex; gap: 5px; align-items: center; }
        
        button { 
            padding: 6px 12px; cursor: pointer; background: #e9ecef; border: 1px solid #ced4da; 
            border-radius: 4px; font-weight: 600; font-size: 14px; min-width: 32px;
        }
        button:active { background: #dde2e6; transform: translateY(1px); }
        button.primary { background: var(--accent); color: white; border-color: var(--accent); }
        
        /* --- VIEWPORT (Het scrollbare gebied) --- */
        .viewport { 
            flex: 1; 
            overflow: auto; /* Zorgt voor scrollbalken */
            padding: 20px; 
            display: flex; 
            align-items: flex-start; /* Belangrijk: forceert start linksboven */
            justify-content: flex-start;
            position: relative;
            background: #404040; /* Donkere achtergrond voor contrast */
        }
        
        /* --- WRAPPER (De container van het plaatje) --- */
        .canvas-wrapper { 
            position: relative; 
            background: white; 
            touch-action: none; 
            /* CRUCIAAL: Voorkomt dat flexbox dit element verkleint */
            flex-shrink: 0; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* Margin auto zorgt voor centreren als er ruimte over is, 
               maar laat het links uitlijnen als het te groot is */
            margin: auto; 
        }
        
        /* Canvas mag GEEN 100% width hebben in CSS, want dat veroorzaakt de vervorming.
           De grootte wordt nu puur door JS (style.width) bepaald. */
        canvas { 
            display: block; 
        }
        
        #selection-box { 
            position: absolute; border: 2px solid var(--accent); 
            background: rgba(13, 110, 253, 0.2); display: none; pointer-events: none; z-index: 50; 
        }

        /* --- FOOTER --- */
        .footer { 
            background: var(--panel); padding: 10px; border-top: 1px solid var(--border); 
            display: flex; flex-direction: column; gap: 8px; z-index: 100;
        }
        
        textarea#ocr-result { 
            width: 100%; height: 60px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            font-family: monospace; font-size: 1.1em; resize: none; box-sizing: border-box;
        }
        textarea#ocr-result:focus { outline: 2px solid var(--accent); border-color: transparent; }

        .footer-row { display: flex; justify-content: space-between; align-items: center; }
        .status { font-size: 0.8em; color: #666; }

        /* Mobiele optimalisatie */
        @media (max-width: 600px) {
            .viewport { padding: 10px; }
            #file-input { max-width: 160px; font-size: 0.75em; }
            .toolbar { gap: 4px; padding: 5px; }
            button { padding: 5px 8px; font-size: 12px; }
        }
    </style>
</head>
<body>

<div class="toolbar">
    <div class="group">
        <input type="file" id="file-input" accept="image/*,application/pdf">
    </div>
    <div class="group">
        <button onclick="changeZoom(-0.2)">－</button>
        <span id="zoom-level" style="font-size: 0.8em; min-width: 35px; text-align: center; color: #333;">100%</span>
        <button onclick="changeZoom(0.2)">＋</button>
    </div>
    <div class="group">
        <button onclick="changePage(-1)" id="prev-btn" disabled>❮</button>
        <span id="page-indicator" style="font-size: 0.8em; color: #333;">-</span>
        <button onclick="changePage(1)" id="next-btn" disabled>❯</button>
        <button onclick="rotateDocument()" title="Draaien">↻</button>
    </div>
</div>

<div class="viewport" id="viewport">
    <div class="canvas-wrapper" id="wrapper">
        <canvas id="main-canvas"></canvas>
        <div id="selection-box"></div>
    </div>
</div>

<div class="footer">
    <textarea id="ocr-result" placeholder="Trek een vakje om tekst te kopiëren..."></textarea>
    <div class="footer-row">
        <span class="status" id="status-msg">Wacht op bestand...</span>
        <button class="primary" onclick="copyText()">KOPIEER</button>
    </div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // State
    let pdfDoc = null;
    let pageNum = 1;
    let rotation = 0;
    let currentZoom = 1.0; 
    let currentImage = null;
    
    // DOM Elements
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('wrapper');
    const selectionBox = document.getElementById('selection-box');
    const resultBox = document.getElementById('ocr-result');
    const statusMsg = document.getElementById('status-msg');

    // --- BESTAND LADEN ---
    document.getElementById('file-input').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        resetState();
        statusMsg.innerText = "Bezig met laden...";

        if (file.type === "application/pdf") {
            const arrayBuffer = await file.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
            document.getElementById('page-indicator').innerText = `1 / ${pdfDoc.numPages}`;
            updatePaginationButtons();
            renderPage(pageNum);
        } else {
            const img = new Image();
            img.onload = () => {
                currentImage = img;
                renderImage();
            };
            img.src = URL.createObjectURL(file);
            document.getElementById('page-indicator').innerText = "IMG";
        }
    };

    function resetState() {
        pdfDoc = null;
        currentImage = null;
        pageNum = 1;
        rotation = 0;
        currentZoom = 1.0; // Reset naar 100% bij nieuw bestand
        updateZoomDisplay();
        selectionBox.style.display = 'none';
        resultBox.value = "";
    }

    // --- ZOOM LOGICA ---
    function changeZoom(delta) {
        if (!pdfDoc && !currentImage) return;
        const newZoom = Math.max(0.1, Math.min(5.0, currentZoom + delta));
        currentZoom = parseFloat(newZoom.toFixed(1));
        
        updateZoomDisplay();
        
        // Alleen de CSS aanpassen, niet opnieuw renderen (sneller)
        updateVisualSize(); 
    }

    function updateZoomDisplay() {
        document.getElementById('zoom-level').innerText = Math.round(currentZoom * 100) + "%";
    }

    // --- RENDERING ---
    async function renderPage(num) {
        if(!pdfDoc) return;
        statusMsg.innerText = "Renderen...";
        const page = await pdfDoc.getPage(num);
        
        // We renderen ALTIJD op hoge resolutie (scale 2.0 of 3.0) voor de OCR
        // De 'zoom' is puur visueel via CSS
        const viewport = page.getViewport({ scale: 2.0, rotation: rotation });
        
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        // Pas de CSS grootte aan op basis van zoom
        updateVisualSize();

        await page.render({ canvasContext: ctx, viewport: viewport }).promise;
        document.getElementById('page-indicator').innerText = `${num} / ${pdfDoc.numPages}`;
        statusMsg.innerText = "Klaar. Selecteer tekst.";
    }

    function renderImage() {
        if (!currentImage) return;
        const isRotated = rotation % 180 !== 0;
        
        // Interne resolutie
        canvas.width = isRotated ? currentImage.height : currentImage.width;
        canvas.height = isRotated ? currentImage.width : currentImage.height;
        
        updateVisualSize();

        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(rotation * Math.PI / 180);
        ctx.drawImage(currentImage, -currentImage.width/2, -currentImage.height/2);
        ctx.restore();
        statusMsg.innerText = "Klaar. Selecteer tekst.";
    }

    function updateVisualSize() {
        // Dit is de fix voor de vervorming:
        // We stellen harde pixels in op de style.
        const visualWidth = Math.floor(canvas.width * currentZoom);
        const visualHeight = Math.floor(canvas.height * currentZoom);

        // Stel grootte in op wrapper én canvas style
        wrapper.style.width = visualWidth + "px";
        wrapper.style.height = visualHeight + "px";
        canvas.style.width = visualWidth + "px";
        canvas.style.height = visualHeight + "px";
    }

    // --- NAVIGATIE & ROTATIE ---
    function changePage(offset) {
        if (!pdfDoc) return;
        const newPage = pageNum + offset;
        if (newPage >= 1 && newPage <= pdfDoc.numPages) {
            pageNum = newPage;
            renderPage(pageNum);
            updatePaginationButtons();
        }
    }

    function updatePaginationButtons() {
        if(!pdfDoc) return;
        document.getElementById('prev-btn').disabled = pageNum <= 1;
        document.getElementById('next-btn').disabled = pageNum >= pdfDoc.numPages;
    }

    function rotateDocument() {
        rotation = (rotation + 90) % 360;
        if (pdfDoc) renderPage(pageNum);
        else renderImage();
    }

    // --- SELECTIE LOGICA ---
    let isDrawing = false;
    let startX, startY;

    function getPointerPos(e) {
        const rect = wrapper.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Positie binnen de wrapper
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function startDraw(e) {
        if (e.target !== canvas && e.target !== selectionBox) return;
        if(e.type === 'touchstart') document.body.style.overflow = 'hidden'; 
        
        isDrawing = true;
        const pos = getPointerPos(e);
        startX = pos.x;
        startY = pos.y;
        
        selectionBox.style.display = 'block';
        selectionBox.style.left = startX + 'px';
        selectionBox.style.top = startY + 'px';
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
    }

    function moveDraw(e) {
        if (!isDrawing) return;
        e.preventDefault(); 

        const pos = getPointerPos(e);
        const w = pos.x - startX;
        const h = pos.y - startY;

        selectionBox.style.width = Math.abs(w) + 'px';
        selectionBox.style.height = Math.abs(h) + 'px';
        selectionBox.style.left = (w < 0 ? pos.x : startX) + 'px';
        selectionBox.style.top = (h < 0 ? pos.y : startY) + 'px';
    }

    function endDraw(e) {
        if (!isDrawing) return;
        isDrawing = false;
        document.body.style.overflow = ''; 

        // Reken terug van scherm-pixels naar echte canvas-pixels
        const rect = selectionBox.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();
        
        // De scale factor is nu simpelweg 1 / currentZoom
        // (Bijvoorbeeld: als zoom 200% (2.0) is, is 1 pixel op scherm 0.5 pixel in canvas)
        const scale = 1 / currentZoom;

        const x = (rect.left - wrapperRect.left) * scale;
        const y = (rect.top - wrapperRect.top) * scale;
        const w = rect.width * scale;
        const h = rect.height * scale;

        if (w > 5 && h > 5) {
            doOCR(x, y, w, h);
        }
    }

    wrapper.addEventListener('mousedown', startDraw);
    window.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);
    wrapper.addEventListener('touchstart', startDraw, {passive: false});
    window.addEventListener('touchmove', moveDraw, {passive: false});
    window.addEventListener('touchend', endDraw);

    // --- OCR ---
    async function doOCR(x, y, w, h) {
        statusMsg.innerText = "⏳ Lezen...";
        resultBox.value = "...";
        
        try {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tCtx = tempCanvas.getContext('2d');
            
            tCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);

            const result = await Tesseract.recognize(tempCanvas.toDataURL(), 'nld+eng');
            const cleanText = result.data.text.trim();
            
            resultBox.value = cleanText;
            statusMsg.innerText = cleanText ? "Gevonden!" : "Geen tekst.";
            if(cleanText) resultBox.focus();
            
        } catch (err) {
            statusMsg.innerText = "Fout";
            console.error(err);
        }
    }

    function copyText() {
        const text = resultBox.value;
        if(text) {
            navigator.clipboard.writeText(text);
            statusMsg.innerText = "✔ Gekopieerd!";
            setTimeout(() => statusMsg.innerText = "Klaar.", 2000);
        }
    }
</script>

</body>
</html>
