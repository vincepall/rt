<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <a href="index.html" class="home-icon"><i class="fas fa-home"></i></a>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <title>Bundelgrootte</title>
    <style>
        /* Bestaande CSS-stijlen */
        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }
        label, select, input {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }
        select, input {
            padding: 8px;
            font-size: 16px;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #646464;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #666;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            color: black;
            text-shadow: none;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
<button class="info-btn" onclick="openModal('myModal')">i</button>

<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal('myModal')">&times;</span>
        <p>Bundelgrootte berekenen of de benodigde FFD. Deze tool ondersteunt zowel vlakke platen als vaten (van binnen naar buiten, EN-8/ASME-B). Formule voor gebogen plaat: ((alpha - 2 * arcsin(((diameter - 2 * FFD) / diameter) * sin(alpha / 2))) / 360) * pi * diameter. Let op: "FFD" in de context van de gebogen plaat verwijst naar de afstand van de bron tot de belichte wand. Nuttig bereik is het gedeelte waar de doorstraalde dikte niet meer dan de opgegeven limiet toeneemt.</p>
    </div>
</div>

<script>
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
    }
</script>

<div class="container">
    <h1 style="color: #F5DF4D; text-align: center;">Bundelgrootte</h1>

    <label for="tubeSelect">Kies een bron:</label>
    <select id="tubeSelect">
        <option value="yxlon300">Yxlon 300 3mm brandvlek: 40° x 55°</option>
        <option value="smartEvo300">Yxlon Smart EVO 300DS: 30° x 60°</option>
        <option value="balteauCeram300">Balteau Ceram 300 Directional: 40° x 50°</option>
        <option value="Se75breed">Selenium 75 met brede collimator: 90° x 90°</option>
        <option value="Se75smal">Selenium 75 met smalle collimator: 60° x 60°</option>
    </select>

    <label for="plateType">Opstelling:</label>
    <select id="plateType">
        <option value="vlak">Vlakke plaat</option>
        <option value="gebogen">Vat, opstelling EN-8 / ASME-B (van binnen naar buiten)</option>
    </select>

    <label for="calcType">Wat wil je weten:</label>
    <select id="calcType">
        <option value="" disabled selected>Kies een berekening</option>
        <option value="size">Bundelgrootte op een bepaalde FFD</option>
        <option value="ffd">Benodigde FFD</option>
        <option value="useful">Nuttig bereik (incl. wanddikte en toename)</option>
    </select>

    <div id="ffdField" class="hidden">
        <label for="ffd">Film Focus Afstand (FFD) in cm:</label>
        <input type="number" id="ffd" step="any">
    </div>

    <div id="beamSizeField" class="hidden">
        <label for="beamSize">Gewenste bundelgrootte in cm:</label>
        <input type="number" id="beamSize" step="any">
    </div>

    <div id="diameterField" class="hidden">
        <label for="diameter">Diameter van het vat in cm:</label>
        <input type="number" id="diameter" step="any">
    </div>

    <div id="wallThicknessField" class="hidden">
        <label for="wallThickness">Wanddikte van het vat in cm:</label>
        <input type="number" id="wallThickness" step="any">
    </div>

    <div id="maxThicknessIncreaseField" class="hidden">
        <label for="maxThicknessIncrease">Max. toegestane dikte-toename (percentage, bijv. 10 voor 10%):</label>
        <input type="number" id="maxThicknessIncrease" step="any">
    </div>

    <button onclick="calculate()">Bereken</button>

    <div id="result" class="result"></div>
</div>

<script>
    const tubeData = {
        yxlon300: { narrow: 40, wide: 55 },
        smartEvo300: { narrow: 30, wide: 60 },
        balteauCeram300: { narrow: 40, wide: 50 },
        Se75breed: { narrow: 90, wide: 90 },
        Se75smal: { narrow: 60, wide: 60 }
    };

    document.getElementById('calcType').addEventListener('change', updateFields);
    document.getElementById('plateType').addEventListener('change', updateFields);

    function updateFields() {
        const calcType = document.getElementById('calcType').value;
        const plateType = document.getElementById('plateType').value;

        document.getElementById('ffdField').classList.toggle('hidden', calcType !== 'size' && calcType !== 'useful');
        document.getElementById('beamSizeField').classList.toggle('hidden', calcType !== 'ffd');
        document.getElementById('diameterField').classList.toggle('hidden', plateType !== 'gebogen');
        document.getElementById('wallThicknessField').classList.toggle('hidden', calcType !== 'useful' || plateType !== 'gebogen');
        document.getElementById('maxThicknessIncreaseField').classList.toggle('hidden', calcType !== 'useful' || plateType !== 'gebogen');
    }

    function calculate() {
        const tube = document.getElementById('tubeSelect').value;
        const calcType = document.getElementById('calcType').value;
        const plateType = document.getElementById('plateType').value;
        const angles = tubeData[tube];
        const narrowAngleDeg = angles.narrow;
        const wideAngleDeg = angles.wide;

        const ffd = parseFloat(document.getElementById('ffd').value);
        const beamSize = parseFloat(document.getElementById('beamSize').value);
        const diameter = parseFloat(document.getElementById('diameter').value);
        const wallThickness = parseFloat(document.getElementById('wallThickness').value);
        const maxThicknessIncrease = parseFloat(document.getElementById('maxThicknessIncrease').value); // In percentage

        let resultText = '';

        // Input validatie
        if (calcType === 'size' && (isNaN(ffd) || ffd <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige FFD in.';
            return;
        }
        if (calcType === 'ffd' && (isNaN(beamSize) || beamSize <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige bundelgrootte in.';
            return;
        }
        if (plateType === 'gebogen' && (isNaN(diameter) || diameter <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige diameter in.';
            return;
        }
        if (calcType === 'useful' && (isNaN(wallThickness) || wallThickness <= 0 || isNaN(maxThicknessIncrease) || maxThicknessIncrease <= 0 || isNaN(diameter) || diameter <= 0 || isNaN(ffd) || ffd <= 0)) {
             document.getElementById('result').innerHTML = 'Voer geldige waarden in voor FFD, Diameter, Wanddikte en Max. dikte-toename.';
             return;
        }


        if (calcType === 'size') {
            if (plateType === 'vlak') {
                const narrowBeam = 2 * ffd * Math.tan(narrowAngleDeg * Math.PI / 360);
                const wideBeam = 2 * ffd * Math.tan(wideAngleDeg * Math.PI / 360);
                resultText = `Vlakke plaat:<br>Aan de smalle kant: ${narrowBeam.toFixed(2)} cm<br>Aan de brede kant: ${wideBeam.toFixed(2)} cm`;
            } else { // Gebogen plaat
                const narrowBeam = curvedBeamSizeAlways(narrowAngleDeg, diameter, ffd);
                const wideBeam = curvedBeamSizeAlways(wideAngleDeg, diameter, ffd);
                resultText = `Gebogen plaat (totale belichte lengte):<br>Aan de smalle kant: ${narrowBeam.toFixed(2)} cm<br>Aan de brede kant: ${wideBeam.toFixed(2)} cm`;
            }
        }

        if (calcType === 'ffd') {
            if (plateType === 'vlak') {
                const narrowFFD = beamSize / (2 * Math.tan(narrowAngleDeg * Math.PI / 360));
                const wideFFD = beamSize / (2 * Math.tan(wideAngleDeg * Math.PI / 360));
                resultText = `Vlakke plaat:<br>Benodigde FFD voor smalle kant: ${narrowFFD.toFixed(2)} cm<br>Benodigde FFD voor brede kant: ${wideFFD.toFixed(2)} cm`;
            } else { // Gebogen plaat
                const narrowFFD = findCurvedFFDAlways(narrowAngleDeg, diameter, beamSize);
                const wideFFD = findCurvedFFDAlways(wideAngleDeg, diameter, beamSize);

                resultText = `Gebogen plaat:<br>`;
                resultText += `Benodigde FFD voor smalle kant: ${narrowFFD !== null ? narrowFFD.toFixed(2) + ' cm' : 'Niet mogelijk (FFD te groot)'}<br>`;
                resultText += `Benodigde FFD voor brede kant: ${wideFFD !== null ? wideFFD.toFixed(2) + ' cm' : 'Niet mogelijk (FFD te groot)'}`;
            }
        }

        if (calcType === 'useful') {
            if (plateType === 'vlak') {
                resultText = `Nuttig bereik is alleen van toepassing op gebogen platen.`;
            } else { // Gebogen plaat
                const usefulNarrow = calculateUsefulBeamSize(narrowAngleDeg, diameter, ffd, wallThickness, maxThicknessIncrease);
                const usefulWide = calculateUsefulBeamSize(wideAngleDeg, diameter, ffd, wallThickness, maxThicknessIncrease);

                if (usefulNarrow === null) {
                    resultText = `Gebogen plaat (nuttig bereik):<br>Smalle kant: De condities (FFD/bronpositie) laten geen nuttig bereik toe binnen de bundel of de max. toename is te streng.`;
                } else {
                    resultText = `Gebogen plaat (nuttig bereik):<br>Aan de smalle kant: ${usefulNarrow.toFixed(2)} cm`;
                }
                if (usefulWide === null) {
                    resultText += `<br>Brede kant: De condities (FFD/bronpositie) laten geen nuttig bereik toe binnen de bundel of de max. toename is te streng.`;
                } else {
                    resultText += `<br>Aan de brede kant: ${usefulWide.toFixed(2)} cm`;
                }
            }
        }

        document.getElementById('result').innerHTML = resultText;
    }

    // Bestaande functie voor totale bundelgrootte op gebogen plaat
    function curvedBeamSizeAlways(angleDeg, diameter, ffd) {
        const alpha = angleDeg * Math.PI / 180; // Hele bundelhoek in radialen
        const sinHalfAlpha = Math.sin(alpha / 2);
        const inner = ((diameter - 2 * ffd) / diameter) * sinHalfAlpha;
        const correctedAlpha = alpha - 2 * Math.asin(Math.max(Math.min(inner, 1), -1)); // De hoek zoals gezien vanuit het midden
        return (correctedAlpha / (2 * Math.PI)) * Math.PI * diameter; // Booglengte
    }

    // Bestaande functie voor het vinden van FFD op gebogen plaat
    function findCurvedFFDAlways(angleDeg, diameter, targetBeam) {
        let low = 0.1, high = diameter * 2;
        let mid;
        let iterations = 0;
        const maxIterations = 100;
        const tolerance = 0.01;

        if (targetBeam <= 0) return Infinity;
        if (targetBeam > Math.PI * diameter) return null;

        while (high - low > tolerance && iterations < maxIterations) {
            mid = (low + high) / 2;
            const beam = curvedBeamSizeAlways(angleDeg, diameter, mid);
            if (beam > targetBeam) {
                low = mid;
            } else {
                high = mid;
            }
            iterations++;
        }
        if (iterations >= maxIterations -1 || Math.abs(curvedBeamSizeAlways(angleDeg, diameter, mid) - targetBeam) > tolerance * 2) {
             return null;
        }

        return mid;
    }


    /**
     * Berekent de hoek tussen de stralingsrichting (LP) en de normaal op de wand (OP).
     * @param {number} wallRadius - Straal van het vat (R).
     * @param {number} sourceX - X-coördinaat van de lichtbron.
     * @param {number} sourceY - Y-coördinaat van de lichtbron (meestal 0).
     * @param {number} pointAngleRad - Hoek van het punt op de wand t.o.v. de x-as (radiaal).
     * @returns {number} De hoek van instraling ten opzichte van de normaal op de wand (in radialen).
     */
    function calculateWallAngle(wallRadius, sourceX, sourceY, pointAngleRad) {
        const pointX = wallRadius * Math.cos(pointAngleRad);
        const pointY = wallRadius * Math.sin(pointAngleRad);

        // Vector van middelpunt naar punt op wand (normaalvector)
        const vecNormalX = pointX;
        const vecNormalY = pointY;

        // Vector van lichtbron naar punt op wand (stralingsrichting)
        const vecBeamX = pointX - sourceX;
        const vecBeamY = pointY - sourceY;

        // Dot product
        const dotProduct = vecNormalX * vecBeamX + vecNormalY * vecBeamY;

        // Magnitudes
        const magNormal = wallRadius; // Dit is R
        const magBeam = Math.sqrt(vecBeamX * vecBeamX + vecBeamY * vecBeamY);

        if (magNormal === 0 || magBeam === 0) return Math.PI / 2; // Voorkom delen door nul

        // Cosinus van de hoek tussen de twee vectoren
        const cosAngle = dotProduct / (magNormal * magBeam);

        // Arccosinus geeft de hoek in radialen. Clamp voor numerieke stabiliteit.
        return Math.acos(Math.max(-1, Math.min(1, cosAngle)));
    }


    /**
     * Berekent het nuttige bereik op een gebogen plaat.
     * @param {number} angleDeg - De totale bundelhoek van de bron (graden).
     * @param {number} diameter - Diameter van het vat (cm).
     * @param {number} ffd - Film Focus Afstand (cm), afstand bron tot belichte wand.
     * @param {number} wallThickness - Wanddikte van het vat (cm).
     * @param {number} maxThicknessIncreasePerc - Max. toegestane dikte-toename in percentage (bijv. 10 voor 10%).
     * @returns {number | null} Het nuttige bereik in cm, of null als niet mogelijk.
     */
    function calculateUsefulBeamSize(angleDeg, diameter, ffd, wallThickness, maxThicknessIncreasePerc) {
        const R = diameter / 2; // Straal van het vat

        // 1. Bereken de maximale toegestane hoek van instraling t.o.v. de normaal (theta_w_max)
        const maxThicknessIncreaseRatio = maxThicknessIncreasePerc / 100;
        const cosThetaWMax = 1 / (1 + maxThicknessIncreaseRatio);
        const thetaWMax = Math.acos(Math.max(-1, Math.min(1, cosThetaWMax))); // In radialen

        // 2. Bepaal de absolute X-positie van de lichtbron
        let sourceXPos;
        let nominalCenterAngleForIteration; // De centrale hoek waar de bundel omheen symmetrisch is voor iteratie

        // Bepaal de 'd' (afstand bron tot middelpunt)
        let d;
        if (ffd > R) { // Bundel naar de 'verre' wand (EN-8/ASME-B inside-out)
            d = ffd - R;
            sourceXPos = d; // Bron is op (d, 0)
            nominalCenterAngleForIteration = Math.PI; // Midden van de belichte boog is op (-R, 0)
        } else if (ffd < R) { // Bundel naar de 'dichte' wand (bron heel dicht bij wand)
            d = R - ffd;
            sourceXPos = -d; // Bron is op (-d, 0) om de belichte boog rond (R,0) te hebben
            nominalCenterAngleForIteration = 0; // Midden van de belichte boog is op (R, 0)
        } else { // ffd == R, bron ligt op de pijpwand zelf of op het middelpunt
            // Dit is een randgeval. Als FFD=R, dan d=0 (bron in midden)
            // of als de bron precies op de wand zit.
            // Voor de formules hierboven moet d bekend zijn.
            // Als FFD = R, dan is de bron effectief in het middelpunt.
            d = 0;
            sourceXPos = 0;
            nominalCenterAngleForIteration = 0; // Of elke hoek, want is symmetrisch
            // Als d=0, dan is de hoek altijd 0. Dit is een makkelijk geval.
            // Als d=0, cosThetaWMax moet dan 1 zijn (geen toename)
            if (maxThicknessIncreasePerc > 0) return null; // Geen toename toegestaan als d=0, tenzij maxincrease = 0
            if (cosThetaWMax < 0.99999) return null; // Als er een toename is toegestaan, maar d=0 dan is de hele bundel nuttig
            return curvedBeamSizeAlways(angleDeg, diameter, ffd); // De hele bundel is nuttig
        }

        // Als d > R (bron buiten de pijp) dan werkt deze specifieke inside-out formule niet.
        // De context is 'van binnen naar buiten'.
        if (d > R + 0.001) { // Kleine tolerantie
            return null; // Bron buiten de pijp, valt buiten dit model
        }


        // De broncoördinaten die we aan calculateWallAngle doorgeven:
        const source_x = sourceXPos;
        const source_y = 0; // Bron ligt op de X-as

        // 3. Bepaal het bereik van de totale belichte bundel (hoeken)
        const alphaRad = angleDeg * Math.PI / 180; // Bundelhoek in radialen
        const sinHalfAlpha = Math.sin(alphaRad / 2);
        const innerTerm = ((diameter - 2 * ffd) / diameter) * sinHalfAlpha;
        const correctedAlphaTotal = alphaRad - 2 * Math.asin(Math.max(Math.min(innerTerm, 1), -1));

        const halfTotalAngle = correctedAlphaTotal / 2;
        // Start- en eindhoeken van de totale belichte bundel ten opzichte van de x-as
        // De belichte boog is gecentreerd rond nominalCenterAngleForIteration
        let totalBeamStartRad = nominalCenterAngleForIteration - halfTotalAngle;
        let totalBeamEndRad = nominalCenterAngleForIteration + halfTotalAngle;

        // 4. Zoek de grenzen van het nuttige bereik
        let usefulStartAngle = null;
        let usefulEndAngle = null;
        const angleStep = 0.001 * Math.PI / 180; // Kleine stap voor precisie

        // Gebruik een kleine correctie voor de iteratie om mogelijke afrondingsfouten bij de grens te voorkomen
        // Begin net iets voor totalBeamStartRad en eindig net iets na totalBeamEndRad
        const iterationStart = totalBeamStartRad - angleStep / 2;
        const iterationEnd = totalBeamEndRad + angleStep / 2;

        for (let angle = iterationStart; angle <= iterationEnd; angle += angleStep) {
            // Normaliseer de hoek voor de calculateWallAngle functie (optioneel, maar maakt het consistenter)
            const normalizedAngle = (angle + 2 * Math.PI) % (2 * Math.PI);
            const currentWallAngle = calculateWallAngle(R, source_x, source_y, normalizedAngle);

            // Als de huidige hoek van de straling op de wand binnen de toelaatbare limiet valt
            if (currentWallAngle <= thetaWMax + 0.0001) { // Kleine tolerantie voor floating point vergelijking
                if (usefulStartAngle === null) {
                    usefulStartAngle = angle; // Dit is de eerste keer dat we in het nuttige bereik komen
                }
                usefulEndAngle = angle; // Update altijd de eindhoek zolang we in het bereik zijn
            } else if (usefulStartAngle !== null) {
                // We zijn buiten het nuttige bereik gekomen na erin te zijn geweest
                break;
            }
        }

        if (usefulStartAngle === null || usefulEndAngle === null || usefulStartAngle > usefulEndAngle) {
            return null; // Geen nuttig bereik gevonden dat voldoet aan de eisen
        }

        const totalUsefulAngleRad = usefulEndAngle - usefulStartAngle;

        // 5. Bereken het nuttige bereik (booglengte)
        const usefulBeamLength = R * totalUsefulAngleRad;

        // Extra controle: het nuttige bereik kan nooit groter zijn dan de totale belichte lengte
        const totalBeamLength = curvedBeamSizeAlways(angleDeg, diameter, ffd);
        if (usefulBeamLength > totalBeamLength + 0.01) { // Kleine tolerantie voor floating point
            // Dit kan voorkomen als thetaWMax heel groot is (bijna pi/2) en de hele bundel nuttig is
            return totalBeamLength;
        }

        return usefulBeamLength;
    }
</script>
</body>
</html>
