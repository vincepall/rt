<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <a href="index.html" class="home-icon"><i class="fas fa-home"></i></a>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <title>Bundelgrootte</title>
    <style>
        /* Bestaande CSS-stijlen */
        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }
        label, select, input {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }
        select, input {
            padding: 8px;
            font-size: 16px;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #646464;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #666;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            color: black;
            text-shadow: none;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
<button class="info-btn" onclick="openModal('myModal')">i</button>

<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal('myModal')">&times;</span>
        <p>Bundelgrootte berekenen of de benodigde FFD. Deze tool ondersteunt zowel vlakke platen als vaten (van binnen naar buiten, EN-8/ASME-B). Formule voor gebogen plaat: ((alpha - 2 * arcsin(((diameter - 2 * FFD) / diameter) * sin(alpha / 2))) / 360) * pi * diameter. Let op: "FFD" in de context van de gebogen plaat verwijst naar de afstand van de bron tot de belichte wand. Nuttig bereik is het gedeelte waar de doorstraalde dikte niet meer dan de opgegeven limiet toeneemt.</p>
    </div>
</div>

<script>
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
    }
</script>

<div class="container">
    <h1 style="color: #F5DF4D; text-align: center;">Bundelgrootte</h1>

    <label for="tubeSelect">Kies een bron:</label>
    <select id="tubeSelect">
        <option value="yxlon300">Yxlon 300 3mm brandvlek: 40° x 55°</option>
        <option value="smartEvo300">Yxlon Smart EVO 300DS: 30° x 60°</option>
        <option value="balteauCeram300">Balteau Ceram 300 Directional: 40° x 50°</option>
        <option value="Se75breed">Selenium 75 met brede collimator: 90° x 90°</option>
        <option value="Se75smal">Selenium 75 met smalle collimator: 60° x 60°</option>
    </select>

    <label for="plateType">Opstelling:</label>
    <select id="plateType">
        <option value="vlak">Vlakke plaat</option>
        <option value="gebogen">Vat, opstelling EN-8 / ASME-B (van binnen naar buiten)</option>
    </select>

    <label for="calcType">Wat wil je weten:</label>
    <select id="calcType">
        <option value="" disabled selected>Kies een berekening</option>
        <option value="size">Bundelgrootte op een bepaalde FFD</option>
        <option value="ffd">Benodigde FFD</option>
        <option value="useful">Nuttig bereik (incl. wanddikte en toename)</option>
    </select>

    <div id="ffdField" class="hidden">
        <label for="ffd">Film Focus Afstand (FFD) in cm:</label>
        <input type="number" id="ffd" step="any">
    </div>

    <div id="beamSizeField" class="hidden">
        <label for="beamSize">Gewenste bundelgrootte in cm:</label>
        <input type="number" id="beamSize" step="any">
    </div>

    <div id="diameterField" class="hidden">
        <label for="diameter">Diameter van het vat in cm:</label>
        <input type="number" id="diameter" step="any">
    </div>

    <div id="wallThicknessField" class="hidden">
        <label for="wallThickness">Wanddikte van het vat in mm:</label>
        <input type="number" id="wallThickness" step="any">
    </div>

    <div id="maxThicknessIncreaseField" class="hidden">
        <label for="maxThicknessIncrease">Max. toegestane dikte-toename (percentage, bijv. 10 voor 10%):</label>
        <input type="number" id="maxThicknessIncrease" step="any">
    </div>

    <button onclick="calculate()">Bereken</button>

    <div id="result" class="result"></div>
</div>

<script>
    const tubeData = {
        yxlon300: { narrow: 40, wide: 55 },
        smartEvo300: { narrow: 30, wide: 60 },
        balteauCeram300: { narrow: 40, wide: 50 },
        Se75breed: { narrow: 90, wide: 90 },
        Se75smal: { narrow: 60, wide: 60 }
    };

    document.getElementById('calcType').addEventListener('change', updateFields);
    document.getElementById('plateType').addEventListener('change', updateFields);

    function updateFields() {
        const calcType = document.getElementById('calcType').value;
        const plateType = document.getElementById('plateType').value;

        document.getElementById('ffdField').classList.toggle('hidden', calcType !== 'size' && calcType !== 'useful');
        document.getElementById('beamSizeField').classList.toggle('hidden', calcType !== 'ffd');
        document.getElementById('diameterField').classList.toggle('hidden', plateType !== 'gebogen');
        document.getElementById('wallThicknessField').classList.toggle('hidden', calcType !== 'useful' || plateType !== 'gebogen');
        document.getElementById('maxThicknessIncreaseField').classList.toggle('hidden', calcType !== 'useful' || plateType !== 'gebogen');
    }

    function calculate() {
        const tube = document.getElementById('tubeSelect').value;
        const calcType = document.getElementById('calcType').value;
        const plateType = document.getElementById('plateType').value;
        const angles = tubeData[tube];
        const narrowAngleDeg = angles.narrow;
        const wideAngleDeg = angles.wide;

        const ffd = parseFloat(document.getElementById('ffd').value);
        const beamSize = parseFloat(document.getElementById('beamSize').value);
        const diameter = parseFloat(document.getElementById('diameter').value);
        let wallThickness = parseFloat(document.getElementById('wallThickness').value); // Nu in mm
        const maxThicknessIncrease = parseFloat(document.getElementById('maxThicknessIncrease').value); // In percentage

        // Converteer wanddikte van mm naar cm
        if (!isNaN(wallThickness)) {
            wallThickness /= 10; // 1 cm = 10 mm
        }

        let resultText = '';

        // Input validatie
        if (calcType === 'size' && (isNaN(ffd) || ffd <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige FFD in.';
            return;
        }
        if (calcType === 'ffd' && (isNaN(beamSize) || beamSize <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige bundelgrootte in.';
            return;
        }
        if (plateType === 'gebogen' && (isNaN(diameter) || diameter <= 0)) {
            document.getElementById('result').innerHTML = 'Voer een geldige diameter in.';
            return;
        }
        if (calcType === 'useful' && (isNaN(wallThickness) || wallThickness <= 0 || isNaN(maxThicknessIncrease) || maxThicknessIncrease <= 0 || isNaN(diameter) || diameter <= 0 || isNaN(ffd) || ffd <= 0)) {
             document.getElementById('result').innerHTML = 'Voer geldige waarden in voor FFD, Diameter, Wanddikte (mm) en Max. dikte-toename.';
             return;
        }


        if (calcType === 'size') {
            if (plateType === 'vlak') {
                const narrowBeam = 2 * ffd * Math.tan(narrowAngleDeg * Math.PI / 360);
                const wideBeam = 2 * ffd * Math.tan(wideAngleDeg * Math.PI / 360);
                resultText = `Vlakke plaat:<br>Aan de smalle kant: ${narrowBeam.toFixed(2)} cm<br>Aan de brede kant: ${wideBeam.toFixed(2)} cm`;
            } else { // Gebogen plaat
                const narrowBeam = curvedBeamSizeAlways(narrowAngleDeg, diameter, ffd);
                const wideBeam = curvedBeamSizeAlways(wideAngleDeg, diameter, ffd);
                resultText = `Gebogen plaat (totale belichte lengte):<br>Aan de smalle kant: ${narrowBeam.toFixed(2)} cm<br>Aan de brede kant: ${wideBeam.toFixed(2)} cm`;
            }
        }

        if (calcType === 'ffd') {
            if (plateType === 'vlak') {
                const narrowFFD = beamSize / (2 * Math.tan(narrowAngleDeg * Math.PI / 360));
                const wideFFD = beamSize / (2 * Math.tan(wideAngleDeg * Math.PI / 360));
                resultText = `Vlakke plaat:<br>Benodigde FFD voor smalle kant: ${narrowFFD.toFixed(2)} cm<br>Benodigde FFD voor brede kant: ${wideFFD.toFixed(2)} cm`;
            } else { // Gebogen plaat
                const narrowFFD = findCurvedFFDAlways(narrowAngleDeg, diameter, beamSize);
                const wideFFD = findCurvedFFDAlways(wideAngleDeg, diameter, beamSize);

                resultText = `Gebogen plaat:<br>`;
                resultText += `Benodigde FFD voor smalle kant: ${narrowFFD !== null ? narrowFFD.toFixed(2) + ' cm' : 'Niet mogelijk (FFD te groot)'}<br>`;
                resultText += `Benodigde FFD voor brede kant: ${wideFFD !== null ? wideFFD.toFixed(2) + ' cm' : 'Niet mogelijk (FFD te groot)'}`;
            }
        }

        if (calcType === 'useful') {
            if (plateType === 'vlak') {
                resultText = `Nuttig bereik is alleen van toepassing op gebogen platen.`;
            } else { // Gebogen plaat
                const usefulNarrow = calculateUsefulBeamSize(narrowAngleDeg, diameter, ffd, wallThickness, maxThicknessIncrease);
                const usefulWide = calculateUsefulBeamSize(wideAngleDeg, diameter, ffd, wallThickness, maxThicknessIncrease);

                if (usefulNarrow === null) {
                    resultText = `Gebogen plaat (nuttig bereik):<br>Smalle kant: De condities (FFD/bronpositie) laten geen nuttig bereik toe binnen de bundel of de max. toename is te streng.`;
                } else {
                    resultText = `Gebogen plaat (nuttig bereik):<br>Aan de smalle kant: ${usefulNarrow.toFixed(2)} cm`;
                }
                if (usefulWide === null) {
                    resultText += `<br>Brede kant: De condities (FFD/bronpositie) laten geen nuttig bereik toe binnen de bundel of de max. toename is te streng.`;
                } else {
                    resultText += `<br>Aan de brede kant: ${usefulWide.toFixed(2)} cm`;
                }
            }
        }

        document.getElementById('result').innerHTML = resultText;
    }

    // Bestaande functie voor totale bundelgrootte op gebogen plaat
    function curvedBeamSizeAlways(angleDeg, diameter, ffd) {
        const alpha = angleDeg * Math.PI / 180; // Hele bundelhoek in radialen
        const sinHalfAlpha = Math.sin(alpha / 2);
        const inner = ((diameter - 2 * ffd) / diameter) * sinHalfAlpha;
        const correctedAlpha = alpha - 2 * Math.asin(Math.max(Math.min(inner, 1), -1)); // De hoek zoals gezien vanuit het midden
        return (correctedAlpha / (2 * Math.PI)) * Math.PI * diameter; // Booglengte
    }

    // Bestaande functie voor het vinden van FFD op gebogen plaat
    function findCurvedFFDAlways(angleDeg, diameter, targetBeam) {
        let low = 0.1, high = diameter * 2;
        let mid;
        let iterations = 0;
        const maxIterations = 100;
        const tolerance = 0.01;

        if (targetBeam <= 0) return Infinity;
        if (targetBeam > Math.PI * diameter) return null;

        while (high - low > tolerance && iterations < maxIterations) {
            mid = (low + high) / 2;
            const beam = curvedBeamSizeAlways(angleDeg, diameter, mid);
            if (beam > targetBeam) {
                low = mid;
            } else {
                high = mid;
            }
            iterations++;
        }
        if (iterations >= maxIterations -1 || Math.abs(curvedBeamSizeAlways(angleDeg, diameter, mid) - targetBeam) > tolerance * 2) {
             return null;
        }

        return mid;
    }


    /**
     * Berekent de hoek tussen de stralingsrichting (LP) en de normaal op de wand (OP).
     * @param {number} wallRadius - Straal van het vat (R).
     * @param {number} sourceX - X-coördinaat van de lichtbron.
     * @param {number} sourceY - Y-coördinaat van de lichtbron (meestal 0).
     * @param {number} pointAngleRad - Hoek van het punt op de wand t.o.v. de x-as (radiaal).
     * @returns {number} De hoek van instraling ten opzichte van de normaal op de wand (in radialen).
     */
    function calculateWallAngle(wallRadius, sourceX, sourceY, pointAngleRad) {
        const pointX = wallRadius * Math.cos(pointAngleRad);
        const pointY = wallRadius * Math.sin(pointAngleRad);

        // Vector van middelpunt naar punt op wand (normaalvector)
        const vecNormalX = pointX;
        const vecNormalY = pointY;

        // Vector van lichtbron naar punt op wand (stralingsrichting)
        const vecBeamX = pointX - sourceX;
        const vecBeamY = pointY - sourceY;

        // Dot product
        const dotProduct = vecNormalX * vecBeamX + vecNormalY * vecBeamY;

        // Magnitudes
        const magNormal = wallRadius; // Dit is R
        const magBeam = Math.sqrt(vecBeamX * vecBeamX + vecBeamY * vecBeamY);

        if (magNormal === 0 || magBeam === 0) return Math.PI / 2; // Voorkom delen door nul

        // Cosinus van de hoek tussen de twee vectoren
        const cosAngle = dotProduct / (magNormal * magBeam);

        // Arccosinus geeft de hoek in radialen. Clamp voor numerieke stabiliteit.
        return Math.acos(Math.max(-1, Math.min(1, cosAngle)));
    }


    /**
     * Berekent het nuttige bereik op een gebogen plaat.
     * @param {number} angleDeg - De totale bundelhoek van de bron (graden).
     * @param {number} diameter - Diameter van het vat (cm).
     * @param {number} ffd - Film Focus Afstand (cm), afstand bron tot belichte wand.
     * @param {number} wallThicknessCM - Wanddikte van het vat (cm).
     * @param {number} maxThicknessIncreasePerc - Max. toegestane dikte-toename in percentage (bijv. 10 voor 10%).
     * @returns {number | null} Het nuttige bereik in cm, of null als niet mogelijk.
     */
    function calculateUsefulBeamSize(angleDeg, diameter, ffd, wallThicknessCM, maxThicknessIncreasePerc) {
        const R = diameter / 2; // Straal van het vat

        // 1. Bereken de maximale toegestane hoek van instraling t.o.v. de normaal (theta_w_max)
        const maxThicknessIncreaseRatio = maxThicknessIncreasePerc / 100;
        const cosThetaWMax = 1 / (1 + maxThicknessIncreaseRatio);
        const thetaWMax = Math.acos(Math.max(-1, Math.min(1, cosThetaWMax))); // In radialen

        // 2. Bepaal de afstand van de bron tot het middelpunt (d)
        // En de absolute X-coördinaat van de bron (sourceXPos)
        // En de nominale middenhoek van het belichte segment (nominalCenterAngleForIteration)

        let d; // Afstand van bron tot middelpunt
        let sourceXPos; // X-coördinaat van de bron
        let nominalCenterAngleForIteration; // Midden van de boog voor iteratie (0 of PI)

        if (ffd > R) { // Bron belicht de 'verre' kant (FFD = R + d)
            d = ffd - R;
            sourceXPos = d; // Bron op (d, 0)
            nominalCenterAngleForIteration = Math.PI; // Belichte boog rond (-R, 0)
        } else if (ffd < R) { // Bron belicht de 'dichte' kant (FFD = R - d)
            d = R - ffd;
            sourceXPos = -d; // Bron op (-d, 0)
            nominalCenterAngleForIteration = 0; // Belichte boog rond (R, 0)
        } else { // ffd == R, bron is in het middelpunt (d=0)
            d = 0;
            sourceXPos = 0;
            nominalCenterAngleForIteration = 0; // Maakt niet uit, is symmetrisch
            // Als de bron in het midden is, is de instralingshoek altijd 0,
            // tenzij de maxThicknessIncreasePerc dit toelaat.
            // Als er geen toename is toegestaan, is thetaWMax 0.
            // Als de bundel een hoek heeft, is de instralingshoek ook 0 voor alle punten.
            // Dus, de hele belichte bundel is nuttig.
            // Echter, als maxThicknessIncreasePerc > 0, en d=0, dan is de hele bundel nuttig,
            // want de hoek van instraling is overal 0.
            if (maxThicknessIncreasePerc === 0 && thetaWMax > 0.0001) { // Als er strikt geen toename mag, en thetaWMax is niet 0, dan is er geen nuttig bereik (behalve het middenpunt)
                return null;
            }
            // Anders, als d=0, is de hele belichte bundel nuttig (want overal loodrecht)
            return curvedBeamSizeAlways(angleDeg, diameter, ffd);
        }

        // Controle of de berekende 'd' realistisch is
        // Als d >= R, betekent dit dat de bron buiten de pijp ligt of precies op de wand
        // in het geval van de 'dichte' kant. Dit model is voor 'inside-out'.
        // Voor FFD < R: als R - FFD >= R, dan FFD <= 0, wat niet kan.
        // Voor FFD > R: als FFD - R >= R, dan FFD >= 2R (bron op of buiten de overkant)
        // De 'curvedBeamSizeAlways' kan FFD's aan waarbij de bron buiten de pijp is.
        // Echter, voor 'nuttig bereik' met wanddikte, is een inside-out aanname vaak het geval.
        // We gaan hier uit van bron binnenin de pijp: d < R.
        if (d >= R) { // Bron op of buiten de diameter, dan is de FFD-logica niet meer 'binnen naar buiten'.
            // Dit kan een scenario zijn waarbij de hele boog nutteloos is of het model niet past.
            return null;
        }

        // 3. Bepaal het bereik van de totale belichte bundel (hoeken)
        const alphaRad = angleDeg * Math.PI / 180; // Bundelhoek in radialen
        const sinHalfAlpha = Math.sin(alphaRad / 2);
        const innerTerm = ((diameter - 2 * ffd) / diameter) * sinHalfAlpha;
        const correctedAlphaTotal = alphaRad - 2 * Math.asin(Math.max(Math.min(innerTerm, 1), -1));

        const halfTotalAngle = correctedAlphaTotal / 2;
        let totalBeamStartRad = nominalCenterAngleForIteration - halfTotalAngle;
        let totalBeamEndRad = nominalCenterAngleForIteration + halfTotalAngle;

        // Normaliseer start- en eindhoeken om iteratie makkelijker te maken
        totalBeamStartRad = (totalBeamStartRad % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
        totalBeamEndRad = (totalBeamEndRad % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
        
        // Zorg ervoor dat de iteratie van start naar eind altijd 'vooruit' gaat
        if (totalBeamStartRad > totalBeamEndRad) {
            totalBeamEndRad += 2 * Math.PI; // Overschrijd 2PI voor iteratie als de bundel over de 0/360 grens gaat
        }

        // 4. Zoek de grenzen van het nuttige bereik
        let usefulStartAngle = null;
        let usefulEndAngle = null;
        const angleStep = 0.001 * Math.PI / 180; // Kleine stap voor precisie (0.001 graden)

        for (let angle = totalBeamStartRad; angle <= totalBeamEndRad; angle += angleStep) {
            // Pas de broncoördinaat aan om consistent te zijn met de hoek van de iteratie
            // Als nominalCenterAngleForIteration == Math.PI, ligt de belichte boog aan de negatieve x-kant.
            // Dan moet de bron X-coördinaat negatief zijn om consistent te blijven met de vector richting.
            // Of we draaien de hoek om, maar dit is eenvoudiger:
            let currentSourceX = sourceXPos;
            if (nominalCenterAngleForIteration === Math.PI) {
                currentSourceX = -sourceXPos; // Bron ligt dan aan de 'negatieve' kant voor deze hoek.
            }
            
            const currentWallAngle = calculateWallAngle(R, currentSourceX, 0, angle);

            if (currentWallAngle <= thetaWMax + 0.0001) { // Kleine tolerantie voor floating point vergelijking
                if (usefulStartAngle === null) {
                    usefulStartAngle = angle;
                }
                usefulEndAngle = angle;
            } else if (usefulStartAngle !== null) {
                // We zijn buiten het nuttige bereik gekomen na erin te zijn geweest
                break;
            }
        }
        
        if (usefulStartAngle === null || usefulEndAngle === null || usefulStartAngle > usefulEndAngle) {
            return null; // Geen nuttig bereik gevonden dat voldoet aan de eisen
        }

        const totalUsefulAngleRad = usefulEndAngle - usefulStartAngle;

        // 5. Bereken het nuttige bereik (booglengte)
        const usefulBeamLength = R * totalUsefulAngleRad;

        // Extra controle: het nuttige bereik kan nooit groter zijn dan de totale belichte lengte
        const totalBeamLength = curvedBeamSizeAlways(angleDeg, diameter, ffd);
        if (usefulBeamLength > totalBeamLength + 0.01) { // Kleine tolerantie voor floating point
            // Dit kan voorkomen als thetaWMax heel groot is (bijna pi/2) en de hele bundel nuttig is
            return totalBeamLength;
        }

        return usefulBeamLength;
    }
</script>
</body>
</html>
