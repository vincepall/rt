<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gevoelige Data Snipper - Versie 2.0</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

    <style>
        :root { --primary: #007bff; }
        body { font-family: sans-serif; margin: 0; padding: 20px; background: #f0f2f5; }
        
        .container { max-width: 1100px; margin: 0 auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        
        /* De container die scrollen toestaat */
        #canvas-wrapper { 
            position: relative; 
            margin-top: 20px; 
            border: 1px solid #ccc; 
            overflow: auto; /* Zorgt dat je kunt scrollen bij grote bestanden */
            max-height: 600px;
            background: #e4e6eb;
            display: inline-block; /* Past zich aan de breedte van de inhoud aan */
            width: 100%;
        }
        
        canvas { 
            display: block; 
            cursor: crosshair; 
            max-width: none; /* Cruciaal: we laten de canvas zijn ware grootte behouden voor de berekening */
        }
        
        /* Het blauwe kader dat je tekent */
        #selection-rect { 
            position: absolute; 
            border: 2px solid var(--primary); 
            background: rgba(0, 123, 255, 0.2); 
            display: none; 
            pointer-events: none; /* Zorgt dat het kader je muiskliks niet blokkeert */
            z-index: 10;
        }

        .output-zone { 
            background: #fff; border-top: 4px solid var(--primary); 
            padding: 15px; margin-top: 20px;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.05);
        }
        
        .status-msg { font-size: 0.85em; color: #555; margin-bottom: 10px; }
    </style>
</head>
<body>

<div class="container">
    <h2>Document Data Snipper</h2>
    <div class="status-msg" id="status">Selecteer een PDF of Foto om te beginnen.</div>
    <input type="file" id="file-upload" accept="image/*,application/pdf">

    <div id="canvas-wrapper">
        <canvas id="main-canvas"></canvas>
        <div id="selection-rect"></div>
    </div>

    <div class="output-zone">
        <div>
            <strong>Gescande Waarde:</strong>
            <div id="ocr-result" style="font-family: monospace; font-size: 1.4em; color: var(--primary);">...</div>
        </div>
        <button style="padding: 10px 20px; cursor:pointer;" onclick="copyResult()">Kopieer</button>
    </div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const selectionRect = document.getElementById('selection-rect');
    const ocrResult = document.getElementById('ocr-result');
    const wrapper = document.getElementById('canvas-wrapper');

    let isDrawing = false;
    let startX, startY; // Dit zijn coördinaten relatief aan de canvas-inhoud

    // --- LADEN ---
    document.getElementById('file-upload').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        if (file.type === "application/pdf") {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({scale: 2.0}); // Goede resolutie voor OCR
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({canvasContext: ctx, viewport: viewport}).promise;
        } else {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            };
            img.src = URL.createObjectURL(file);
        }
        document.getElementById('status').innerText = "Bestand geladen. Gebruik je muis om een vakje te trekken.";
    };

    // --- COÖRDINAAT FIX ---
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        // Bereken de positie relatief t.o.v. de canvas-afbeelding zelf, 
        // rekening houdend met de schaling van de browser
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY,
            // We slaan ook de schermpositie op voor het tekenen van de blauwe box
            screenX: e.clientX - rect.left + wrapper.scrollLeft,
            screenY: e.clientY - rect.top + wrapper.scrollTop
        };
    }

    canvas.onmousedown = (e) => {
        isDrawing = true;
        const pos = getMousePos(e);
        startX = pos.x;
        startY = pos.y;
        
        // Zet de visuele startpositie (relatief aan de wrapper)
        const rect = canvas.getBoundingClientRect();
        selectionRect.style.left = (e.clientX - rect.left + wrapper.scrollLeft) + "px";
        selectionRect.style.top = (e.clientY - rect.top + wrapper.scrollTop) + "px";
        selectionRect.style.width = "0px";
        selectionRect.style.height = "0px";
        selectionRect.style.display = 'block';
    };

    window.onmousemove = (e) => {
        if (!isDrawing) return;
        const pos = getMousePos(e);
        const rect = canvas.getBoundingClientRect();

        // Bereken hoe groot de box moet zijn op het scherm
        const currentScreenX = e.clientX - rect.left + wrapper.scrollLeft;
        const currentScreenY = e.clientY - rect.top + wrapper.scrollTop;
        
        const visualStartX = startX * (rect.width / canvas.width);
        const visualStartY = startY * (rect.height / canvas.height);

        const width = currentScreenX - (visualStartX + wrapper.scrollLeft);
        const height = currentScreenY - (visualStartY + wrapper.scrollTop);

        selectionRect.style.width = Math.abs(width) + "px";
        selectionRect.style.height = Math.abs(height) + "px";
        selectionRect.style.left = Math.min(currentScreenX, visualStartX + wrapper.scrollLeft) + "px";
        selectionRect.style.top = Math.min(currentScreenY, visualStartY + wrapper.scrollTop) + "px";
    };

    window.onmouseup = async (e) => {
        if (!isDrawing) return;
        isDrawing = false;
        const pos = getMousePos(e);
        
        const width = pos.x - startX;
        const height = pos.y - startY;

        if (Math.abs(width) > 5) {
            doOCR(startX, startY, width, height);
        }
    };

    async function doOCR(x, y, w, h) {
        ocrResult.innerText = "Bezig...";
        
        // Snijd het stukje uit de grote afbeelding
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = Math.abs(w);
        tempCanvas.height = Math.abs(h);
        const tempCtx = tempCanvas.getContext('2d');
        
        // We gebruiken de echte coördinaten (x, y, w, h) op de originele resolutie
        tempCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);

        const result = await Tesseract.recognize(tempCanvas.toDataURL(), 'nld+eng');
        ocrResult.innerText = result.data.text.trim();
        navigator.clipboard.writeText(result.data.text.trim());
    }

    function copyResult() {
        navigator.clipboard.writeText(ocrResult.innerText);
        alert("Gekopieerd naar klembord!");
    }
</script>

</body>
</html>
